# go 指针

### 传值与传指针
```
当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。

传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。

Go语言中string，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针）

要访问指针 p 指向的结构体中某个元素 x，不需要显式地使用 * 运算，可以直接 p.x ；
```
参考：https://www.cnblogs.com/ghj1976/archive/2013/02/28/2936595.html


###  注意:
```
func addressStillTest(v *int) {
    x := 456
    v = &x
}
```
go_01.go 第一个方法中传了一个地址进去，但是我们明显不是对地址做的任何修改操作，而是做了一个dereference操作。然后修改了变量的值。而在上面的这个例子中才是对地址的操作。我们在函数addressStillTest中试图修改x指向的地址，由于x的地址是传值操作的，也就是拷贝过来的，所以修改是无效的。最后的输出结果也说明了这一点。

所以在函数操作方面，任何的参数都是按照传值操作(我理解为**地址的值**，实际就是一个地址的copy)的方式执行的。不管是穿的指针还是一般的一个值都是传值使用的。

例子： go_00.go，go_01.go

参考：http://blog.csdn.net/future_challenger/article/details/48465693
